\section{Architettura di sistema} \label{sec:arch}
L'architettura adottata nella realizzazione dell'applicativo segue le linee guida date dalla Clean Architecture. Il software è stato suddiviso in livelli, in base alla tipologia di logica ad esso riferita, secondo una struttura concentrica.\\
Ogni livello o strato dell'applicativo è indipendente da quelli ad esso più esterni, ovvero nulla presente in un livello più interno può conoscere l'implementazione del livello più esterno.\\
Questo principio alla base dell'architettura clean ci permette di ottenere un prodotto software la cui logica di business è del tutto indipendente dal framework utilizzato per la realizzazione dell'interfaccia grafica e dalle basi di dati adottate.\\
Gli elementi che costituiscono l'architettura sono i seguenti:
\begin{description}
    \item[Controller:] è il punto di ingresso per le richieste dall'esterno del sistema. Esso accetta le richieste in arrivo dall'esterno, utilizza gli use case per effettuare le operazioni richieste e gestisce la conversione dei dati ricevuti nei formati appropriati.
    \item[Use case:] rappresentano le singole funzionalità o casi di utilizzo dell'applicazione. Essi contengono la logica di business. Essi coordinano l'esecuzione delle operazioni richieste dalla logica di business, andando a definire ed implementare le regole di business specifiche di ogni funzionalità. Utilizzano i repository per accedere e manipolare i dati.
    \item[Repository:] sono responsabili per l'accesso ai dati persistenti, fornendo un'interfaccia astratta per la comunicazione con il livello di persistenza dei dati sottostante. Astraggono il resto dell'applicazione dai dettagli tecnici specifici del sistema di persistenza dei dati, fornendo i metodi per recuperare, salvare, aggiornare ed eliminare dati.
    \item[Data source:] sono gli elementi che effettivamente accedono e manipolano i dati nel sistema di persistenza sottostante, forniscono l'implementazione concreta dei metodi per l'accesso ai dati presenti nei repository.
\end{description}
L'adozione di una Clean Architecture come architettura di sistema porta numerosi vantaggi:
\begin{itemize}
    \item Elevato grado di modularità del codice, suddividendolo in base alla logica e alle responsabilità che implementa.
    \item Indipendenza della business logic da qualsiasi framework, tecnologie e interfaccia utente adottata. Ogni cambiamento apportato non compromette il corretto funzionamento del sistema.
    \item Il funzionamento del sistema è completamente indipendente dalle tecnologie utilizzate per i database, con le fonti dei dati che possono essere molteplici. Ogni cambiamento apportato non compromette il corretto funzionamento del sistema.
    \item La leggibilità, la comprensibilità e la testabilità dell'intero sistema è semplificata.
\end{itemize}

\begin{figure}[h!]
    \centering  
    \includegraphics[width=0.5\textwidth]{cleanarch.png}
    \caption{Schema della Clean Architecture}
\end{figure}

\newpage

\section{Architettura di deployment} \label{sec:archdeplo}
Nel valutare quale architettura di deployment adottare per l'applicativo, è stato considerato il caso d'utilizzo realistico del prodotto.\\
Essendo l'applicazione pensata per essere utilizzata all'interno di fabbriche o piccole aziende, senza particolari necessità di espansioni del sistema o modifiche sostanziali una volta installato il prodotto, è stato ritenuto vantaggioso e utile optare per un'architettura monolite. Oltre ad essere la scelta migliore per lo scopo finale e le caratteristiche del prodotto, permettendo anche una più semplice fase di progettazione, codifica e test, il  monolite non presenta le stesse difficoltà che avrebbe portato la scelta di altre architetture di deployment, come quella a micro-servizi, la quale sarebbe stata di difficile implementazione considerate anche le competenze e le conoscenze dei membri del gruppo.\\ \\
Il deploy del prodotto avviene tramite containerizzazione con Docker Compose. In questo modo, è possibile facilitare l'installazione dell'applicativo andando a definire un ambiente dove tutte le dipendenze sono risolte, nel quale sono già predisposti correttamente tutti i servizi necessari al corretto utilizzo del prodotto. In particolare, il container predispone al corretto utilizzo dei database, ovvero ChromaDB, Postgres e MinIO, oltre ai servizi di Ollama.
\\ \\ 
Il comando necessario per l'esecuzione del programma è: \\
\texttt{docker compose -f docker-compose-gpu.yml exec -it ollama ollama \\ pull starling-lm:latest}
\vspace{2cm}

\begin{figure}[h!]
    \centering  
    \includegraphics[width=0.5\textwidth]{docker.png}
    \caption{Servizi predisposti dal Docker Compose}
\end{figure}

\newpage